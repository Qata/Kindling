module NeoPixel
include("<Adafruit_NeoPixel.h>")
open(Io, Color, Time)

// The ptr here should be a Adafruit_NeoPixel object
type RawDevice = device(ptr)

alias color = { r : uint8, g : uint8, b : uint8, w : uint8 }

alias DeviceDescriptor = {
    pin : uint16
}

type Function =
    rotate(either<unit, unit>)

alias Operation = {
    function : Function,
    interval : uint32,
    timer : timerState
}

alias PixelState<nPixels : int> = {
    pixels: list<rgb, nPixels>,
    operation: maybe<Operation>,
    pin : uint16,
    device: RawDevice
}

alias Model<nStrips : int, nPixels : int> = {
    states : list<PixelState<nPixels>, nStrips>
}

fun initialState(descriptors : DeviceDescriptor[nStrips], nPixels : uint16): Model<nStrips, m> = {
    {
        states := { data := descriptors, length := cast(nStrips) } |> List:map(
            (descriptor) => {
                {
                    pixels := { data := zeros(), length := cast(nPixels) },
                    operation := nothing(),
                    pin := descriptor.pin,
                    device := makeDevice(descriptor.pin, cast(nPixels))
                }
            }
        )
    }
}

fun makeDevice(pin : uint16, pixels : uint16): RawDevice = {
    var ret : ptr
    #ret = Adafruit_NeoPixel(pixels, pin, NEO_GRB + NEO_KHZ800);#
    NeoPixel:device(ret)
}

fun update(inout model : Model<nStrips, nPixels>) = {
    model.states = model.states |> List:map(
        (state) => {
            let mut state = state
            match state.operation {
                just(op) => {
                    let mut operation = op
                    Time:every(
                        operation.interval,
                        inout operation.timer
                    ) |> Signal:map(
                        (_) => {
                            just(operation)
                        }
                    ) |> Signal:latch(inout state.operation) |> Signal:map(
                        (_) => {
                            applyOperation(
                                operation,
                                state.pixels
                            )
                        }
                    ) |> Signal:latch(inout state.pixels) |> Signal:toUnit()
                }
                nothing() => {
                    Signal:constant(())
                }
            }
            state
        }
    )
}

fun _update(inout model : Model<nStrips, nPixels>) = {
    Signal:constant(
        model.states
    ) |> Signal:map(
        (states) => {
            states |> List:map(
                (state) => {
                    let mut state = state
                    match state.operation {
                        just(op) => {
                            let mut operation = op
                            Time:every(
                                operation.interval,
                                inout operation.timer
                            ) |> Signal:map(
                                (_) => {
                                    just(operation)
                                }
                            ) |> Signal:latch(inout state.operation) |> Signal:map(
                                (_) => {
                                    applyOperation(
                                        operation,
                                        state.pixels
                                    )
                                }
                            ) |> Signal:latch(inout state.pixels) |> Signal:toUnit()
                        }
                        nothing() => {
                            Signal:constant(())
                        }
                    }
                    state
                }
            )
        }
    )// ) |> Signal:latch(inout model.states)
}

fun applyOperation(operation : Operation, pixels : list<rgb, nPixels>): list<rgb, nPixels> = {
    // let nextPixels = List:
    match operation.function {
        rotate(direction) => {
            match direction {
                left(_) => ()
                right(_) => ()
            }
        }
    }
    { data := zeros(), length := cast(nPixels) }
}

fun setPixelColors(colors : list<color, n>, strip : RawDevice) = {
    let device(p) = strip
    colors |> List:map(
        (color) => {
            let r = color.r
            let g = color.g
            let b = color.b
            let w = color.w
            # ((Adafruit_NeoPixel*) p)->setPixelColor(n, r, g, b, w); #
        }
    )
}

fun setPixelColor(n : uint16, c : color, strip : RawDevice) : unit = {
    let device(p) = strip
    let r = c.r
    let g = c.g
    let b = c.b
    let w = c.w
    # ((Adafruit_NeoPixel*) p)->setPixelColor(n, r, g, b, w); #
}

fun makeColor(r : uint8, g : uint8, b : uint8) : color =
    { r := r, g := g, b := b, w := 0u8 }

fun getPixelColor(n : uint16, strip : RawDevice) : color = {
    let device(p) = strip
    let mut numRep : uint32 = 0
    # numRep = ((Adafruit_NeoPixel*) p)->getPixelColor(n); #
    { r := toUInt8(numRep >> 16u32), g := toUInt8(numRep >> 8u32), b := toUInt8(numRep), w := 0u8 }
}

fun setBrightness(level : uint8, strip : RawDevice) : unit = {
    let device(p) = strip
    # ((Adafruit_NeoPixel*) p)->setBrightness(level); #
}

fun getBrightness(strip : RawDevice) : uint8 = {
    let mut ret : uint8 = 0
    let device(p) = strip
    # ret = ((Adafruit_NeoPixel*) p)->getBrightness(); #
    ret
}

fun begin(strip : RawDevice) : unit = {
    let device(p) = strip
    # ((Adafruit_NeoPixel*) p)->begin(); #
}

fun show(strip : RawDevice) : unit = {
    let device(p) = strip
    # ((Adafruit_NeoPixel*) p)->show(); #
}

fun clear(strip : RawDevice) : unit = {
    let device(p) = strip
    # ((Adafruit_NeoPixel*) p)->clear(); #
}

fun canShow(strip : RawDevice) : bool = {
    let device(p) = strip
    let mut ret = false
    # ret = ((Adafruit_NeoPixel*) p)->canShow(); #
    ret
}