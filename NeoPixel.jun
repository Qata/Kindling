module NeoPixel
include("<Adafruit_NeoPixel.h>")
open(Io, Time)

// The ptr here should be a Adafruit_NeoPixel object
type RawDevice = device(ptr)

alias DeviceDescriptor = {
    pin : uint16
}

type color = RGB(uint8, uint8, uint8)

type Function =
rotate(int16)
| set(color)
| alternate(color, color)

type Action =
    run(Function)
    | repeat(Function, uint32, maybe<uint8>)
    | endRepeat()

alias Operation = {
    function : Function,
    interval : uint32,
    timer : timerState
}

alias Line<nPixels : int> = {
    previousPixels : list<color, nPixels>,
    pixels : list<color, nPixels>,
    operation : maybe<Operation>,
    pin : uint16,
    device : RawDevice
}

alias Model<nLines : int, nPixels : int> = {
    lines : list<Line<nPixels>, nLines>
}

let mut actionsTimerState = Time:state
let mut firstAction : maybe<Action> = just(
    run(
        set(
            RGB(
                0,
                0,
                255
            )
        )
    )
)

fun actions(
    inout prevAction : maybe<Action>
) : sig<maybe<Action>> = {
    Signal:constant(
        repeat(
            rotate(1),
            500,
            just(1)
        )
    ) |> Signal:dropRepeats(
        inout prevAction
    ) |> Signal:meta(
    )
}

fun initialState(descriptors : DeviceDescriptor[nLines], nPixels : uint16) : Model<nLines, m> = {
    {
        lines := { data := descriptors, length := cast(nLines) } |> List:map(
            (descriptor) => {
                let device = makeDevice(descriptor.pin, cast(nPixels))
                {
                    previousPixels := readPixels(device),
                    pixels := { data := zeros(), length := cast(nPixels) },
                    operation := nothing(),
                    pin := descriptor.pin,
                    device := device
                }
            }
        )
    }
}

fun readPixels(device : RawDevice): list<color, n> = {
    let mut color = 0u32
    let mut pixels: color[n] = zeros()
    for i in 0u16 .. cast(n) {
        getPixelColor(i, device)
        pixels[i] = RGB(
            toUInt8(color >> 16u32), 
            toUInt8(color >> 8u32), 
            toUInt8(color)
        )
    }
    { data := pixels, length := cast(n) }
}

fun makeDevice(pin : uint16, pixels : uint16) : RawDevice = {
    var ret : ptr
    #ret = Adafruit_NeoPixel(pixels, pin, NEO_GRB + NEO_KHZ800);#
    NeoPixel:device(ret)
}

// fun updateAction(action : inout state : Line<nPixels>) = {
//     match action {
//         run(fn) => ()

//     }
// }

fun updateOperation(state : Line<nPixels>) : Line<nPixels> = {
    let mut state = state
    match state.operation {
        just(op) => {
            let mut operation = op
            Time:every(
                operation.interval,
                inout operation.timer
            ) |> Signal:map(
                (_) => {
                    just(operation)
                }
            ) |> Signal:latch(
                inout state.operation
            ) |> Signal:map(
                (_) => state.pixels
            ) |> Signal:latch(
                inout state.previousPixels
            ) |> Signal:map(
                (_) => applyOperation(
                    operation,
                    state.previousPixels
                )
            ) |> Signal:latch(
                inout state.pixels
            ) |> Signal:map(
                (_) => updatePixels(
                    state
                )
            ) |> Signal:toUnit(
            )
        }
        nothing() => {
            Signal:constant(())
        }
    }
    state
}

type Update = 
    action(Action)
    | operation()

fun __update(act : maybe<Action>, model : Model<nLines, nPixels>) : Model<nLines, nPixels> = {
    let mut model = model
    Signal:mergeMany(
        {
            data := [
                signal(act) |> Signal:map(action),
                Signal:constant(operation())
            ],
            length := 2
        }
    ) |> Signal:map(
        (update) => {
            match update {
                action(action) => {
                    match action {
                        run(fn) => {
                            ()
                        }
                    }
                }
                operation() => {
                    model.lines |> List:map(
                        updateOperation
                    )
                    ()
                }
            }
        }
    )
    model
}

fun update(action : Action, model : Model<nLines, nPixels>) : Model<nLines, nPixels> = {
    let mut model = model
    model.lines = model.lines |> List:map(
        (state) => {
            let mut state = state
            match state.operation {
                just(op) => {
                    let mut operation = op
                    Time:every(
                        operation.interval,
                        inout operation.timer
                    ) |> Signal:map(
                        (_) => just(operation)
                    ) |> Signal:latch(
                        inout state.operation
                    ) |> Signal:map(
                        (_) => state.pixels
                    ) |> Signal:latch(
                        inout state.previousPixels
                    ) |> Signal:map(
                        (_) => applyOperation(
                            operation,
                            state.previousPixels
                        )
                    ) |> Signal:latch(
                        inout state.pixels
                    ) |> Signal:map(
                        (_) => updatePixels(
                            state
                        )
                    ) |> Signal:toUnit(
                    )
                }
                nothing() => {
                    Signal:constant(())
                }
            }
            state
        }
    )
    model
}

fun applyOperation(
    operation : Operation, 
    pixels : list<color, nPixels>
) : list<color, nPixels> = {
    match operation.function {
        rotate(step) => 
            ListExt:rotated(cast(step), pixels)
        set(color) =>
            List:map(
                (_) => color,
                pixels
            )
        alternate(c1, c2) => 
            ListExt:replicateList(
                cast(nPixels),  
                { data := [c1, c2], length := 2 }
            )
    }
}

fun diffPixels(current : list<color, nPixels>, next : list<color, nPixels>) : list<maybe<color>, nPixels> = {
    List:zip(
       current,
       next
    ) |> List:map(
        (tup) => {
            let (curr, next) = tup
            if eq(curr, next)
                nothing()
            else
                just(next)
        }
    )
}

fun updatePixels(state : Line<n>) = {
    diffPixels(
        state.previousPixels,
        state.pixels
    ) |> ListExt:enumerated(
    ) |> List:iter(
        (tup) => {
            let (index, color) = tup
            match color {
                just(pixel) => setPixelColor(cast(index), pixel, state.device)
                nothing() => ()
            }
        }
    )
}

fun setPixelColor(n : uint16, color : color, line : RawDevice) : unit = {
    let device(p) = line
    let RGB(r, g, b) = color
    # ((Adafruit_NeoPixel*) p)->setPixelColor(n, r, g, b); #
}

fun getPixelColor(n : uint16, line : RawDevice) : color = {
    let device(p) = line
    let mut numRep : uint32 = 0
    # numRep = ((Adafruit_NeoPixel*) p)->getPixelColor(n); #
    RGB(
        toUInt8(numRep >> 16u32), 
        toUInt8(numRep >> 8u32), 
        toUInt8(numRep)
    )
}

fun setBrightness(level : uint8, line : RawDevice) : unit = {
    let device(p) = line
    # ((Adafruit_NeoPixel*) p)->setBrightness(level); #
}

fun getBrightness(line : RawDevice) : uint8 = {
    let mut ret : uint8 = 0
    let device(p) = line
    # ret = ((Adafruit_NeoPixel*) p)->getBrightness(); #
    ret
}

fun begin(line : RawDevice) : unit = {
    let device(p) = line
    # ((Adafruit_NeoPixel*) p)->begin(); #
}

fun show(line : RawDevice) : unit = {
    let device(p) = line
    # ((Adafruit_NeoPixel*) p)->show(); #
}

fun clear(line : RawDevice) : unit = {
    let device(p) = line
    # ((Adafruit_NeoPixel*) p)->clear(); #
}

fun canShow(line : RawDevice) : bool = {
    let device(p) = line
    let mut ret = false
    # ret = ((Adafruit_NeoPixel*) p)->canShow(); #
    ret
}