module NeoPixel
include("<Adafruit_NeoPixel.h>")
open(Io, Time)

// The ptr here should be a Adafruit_NeoPixel object
type RawDevice = device(ptr)

alias DeviceDescriptor = {
    pin : uint16
}

type color = RGB(uint8, uint8, uint8)

type Function =
rotate(int16)
| set(color)
| alternate(color, color)

type Action =
    run(uint8, Function)
    | repeat(uint8, Function, uint32, maybe<uint8>)
    | endRepeat(uint8)

alias Operation = {
    function : Function,
    interval : uint32,
    timer : timerState,
    endAfter : maybe<uint8>
}

alias Line<nPixels : int> = {
    previousPixels : list<color, nPixels>,
    pixels : list<color, nPixels>,
    operation : maybe<Operation>,
    pin : uint16,
    device : RawDevice
}

alias Model<nLines : int, nPixels : int> = {
    lines : list<Line<nPixels>, nLines>
}

let mut firstAction : maybe<Action> = just(
    run(
        1,
        set(
            RGB(
                0,
                0,
                255
            )
        )
    )
)

fun actions(
    inout prevAction : maybe<Action>
) : sig<maybe<Action>> = {
    Signal:mergeMany(
        {
            data := [
                SignalExt:once(inout firstAction),
                Signal:constant(
                    repeat(
                        0,
                        rotate(1),
                        500,
                        nothing()
                    )
                )
            ],
            length := 2
        }
    ) |> Signal:meta(
    )
}

fun initialState(descriptors : DeviceDescriptor[nLines], nPixels : uint16) : Model<nLines, m> = {
    {
        lines := { data := descriptors, length := cast(nLines) } |> List:map(
            (descriptor) => {
                let device = makeDevice(descriptor.pin, cast(nPixels))
                let pixels : list<color, nPixels> = { data := zeros(), length := cast(nPixels) }
                {
                    previousPixels := readPixels(device),
                    pixels := pixels,
                    operation := nothing(),
                    pin := descriptor.pin,
                    device := device
                }
            }
        )
    }
}

fun readPixels(device : RawDevice): list<color, n> = {
    let mut color = 0u32
    let mut pixels: color[n] = zeros()
    for i in 0u16 .. cast(n) {
        getPixelColor(i, device)
        pixels[i] = RGB(
            toUInt8(color >> 16u32), 
            toUInt8(color >> 8u32), 
            toUInt8(color)
        )
    }
    { data := pixels, length := cast(n) }
}

fun makeDevice(pin : uint16, pixels : uint16) : RawDevice = {
    var ret : ptr
    #ret = new Adafruit_NeoPixel(pixels, pin, NEO_GRB + NEO_KHZ800);#
    NeoPixel:device(ret)
}

// fun updateAction(action : inout state : Line<nPixels>) = {
//     match action {
//         run(fn) => ()

//     }
// }

fun runOperation(operation : Operation, line : Line<nPixels>) : Line<nPixels> = {
    let mut operation = operation
    let mut line = line
    Time:every(
        operation.interval,
        inout operation.timer
    ) |> Signal:map(
        (_) => {
            just(operation)
        }
    ) |> Signal:latch(
        inout line.operation
    ) |> Signal:map(
        (_) => {
            updateLine(line, operation.function)
        }
    ) |> Signal:latch(
        inout line
    )
    line
}

fun updateOperation(line : Line<nPixels>) : Line<nPixels> = {
    let mut line = line
    match line.operation {
        just(operation) => {
            let mut operation = operation
            line = match operation.endAfter {
                just(0) => {
                    line.operation = nothing()
                    line
                }
                just(n) => {
                    operation.endAfter = just(n - 1)
                    runOperation(operation, line)
                }
                nothing() => {
                    runOperation(operation, line)
                }
            }
            ()
        }
        nothing() => {
            ()
        }
    }
    line
}

fun updateLine(line : Line<nPixels>, fn : Function) : Line<nPixels> = {
    let mut line = line
    line.previousPixels = line.pixels
    line.pixels = applyFunction(
        fn,
        line.previousPixels
    )
    updatePixels(line)
    line
}

type Update = 
    action(Action)
    | operation()

fun update(act : maybe<Action>, model : Model<nLines, nPixels>) : Model<nLines, nPixels> = {
    let mut model = model
    Signal:mergeMany(
        {
            data := [
                signal(act) |> Signal:map(action),
                Signal:constant(operation())
            ],
            length := 2
        }
    ) |> Signal:map(
        (update) => {
            match update {
                action(action) => {
                    let mut lines = model.lines
                    match action {
                        run(line, fn) => {
                            lines.data[line] = updateLine(
                                model.lines.data[line],
                                fn
                            )
                            ()
                        }
                        repeat(line, fn, interval, endAfter) => {
                            lines.data[line] = updateLine(
                                model.lines.data[line],
                                fn
                            )
                            lines.data[line].operation = just(
                                {
                                    function := fn,
                                    interval := interval,
                                    timer := Time:state,
                                    endAfter := endAfter
                                }
                            )
                            ()
                        }
                        endRepeat(line) => {
                            lines.data[line].operation = nothing()
                            ()
                        }
                    }
                    lines
                }
                operation() => {
                    model.lines |> List:map(
                        updateOperation
                    )
                }
            }
        }
    ) |> Signal:latch(
        inout model.lines
    )
    model
}

fun applyFunction(
    fn : Function, 
    pixels : list<color, nPixels>
) : list<color, nPixels> = {
    match fn {
        rotate(step) => 
            ListExt:rotated(cast(step), pixels)
        set(color) =>
            List:map(
                (_) => color,
                pixels
            )
        alternate(c1, c2) => {
            let mut pixels = pixels
            for i in 0 .. nPixels {
                pixels.data[i] = if i % 2 == 0 {
                    c1
                } else {
                    c2
                }
            }
            pixels
            // Does not compile due to codegen bug
            // ListExt:replicateList(
            //     cast(nPixels),
            //     { data := [c1, c2], length := 2 }
            // )
        }
    }
}

fun diffPixels(current : list<color, nPixels>, next : list<color, nPixels>) : list<maybe<color>, nPixels> = {
    List:zip(
       current,
       next
    ) |> List:map(
        (tup) => {
            let (curr, next) = tup
            if eq(curr, next)
                nothing()
            else
                just(next)
        }
    )
}

fun updatePixels(state : Line<n>) = {
    diffPixels(
        state.previousPixels,
        state.pixels
    ) |> ListExt:enumerated(
    ) |> List:iter(
        (tup) => {
            let (index, color) = tup
            match color {
                just(pixel) => setPixelColor(cast(index), pixel, state.device)
                nothing() => ()
            }
        }
    )
    show(state.device)
}

fun setPixelColor(n : uint16, color : color, line : RawDevice) : unit = {
    let device(p) = line
    let RGB(r, g, b) = color
    # ((Adafruit_NeoPixel*) p)->setPixelColor(n, r, g, b); #
}

fun getPixelColor(n : uint16, line : RawDevice) : color = {
    let device(p) = line
    let mut numRep : uint32 = 0
    # numRep = ((Adafruit_NeoPixel*) p)->getPixelColor(n); #
    RGB(
        toUInt8(numRep >> 16u32), 
        toUInt8(numRep >> 8u32), 
        toUInt8(numRep)
    )
}

fun setBrightness(level : uint8, line : RawDevice) : unit = {
    let device(p) = line
    # ((Adafruit_NeoPixel*) p)->setBrightness(level); #
}

fun getBrightness(line : RawDevice) : uint8 = {
    let mut ret : uint8 = 0
    let device(p) = line
    # ret = ((Adafruit_NeoPixel*) p)->getBrightness(); #
    ret
}

fun begin(line : RawDevice) : unit = {
    let device(p) = line
    # ((Adafruit_NeoPixel*) p)->begin(); #
}

fun show(line : RawDevice) : unit = {
    let device(p) = line
    # ((Adafruit_NeoPixel*) p)->show(); #
}

fun clear(line : RawDevice) : unit = {
    let device(p) = line
    # ((Adafruit_NeoPixel*) p)->clear(); #
}

fun canShow(line : RawDevice) : bool = {
    let device(p) = line
    let mut ret = false
    # ret = ((Adafruit_NeoPixel*) p)->canShow(); #
    ret
}