module TEA

let mut tState1 = Time:state
let mut tState2 = Time:state

type Action = increment() | decrement()

alias Model = {
    counter : int32
}

let initialState : Model = { counter := 0 }
let mut state : Model = initialState

fun update(action : Action, model : Model): Model = {
    let mut model = model
    match action {
        increment => model.counter += 1
        decrement => model.counter -= 1
    }
    model
}

fun actions(): sig<Action> = {
    Signal:merge(
        Time:every(1000, inout tState1) |> Signal:map(
            (_) => {
                increment()
            }
        ),
        Time:every(2000, inout tState2) |> Signal:map(
            (_) => {
                decrement()
            }
        )
    )
}

fun setup() = ()
fun loop() = {
    Signal:foldP(
        update,
        inout state,
        actions()
    ) |> Signal:map(
        (state) => {
            Io:printInt(state.counter)
        }
    )
}